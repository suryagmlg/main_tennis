<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Americano Score by SG</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --court-green: #2d5016;
            --court-blue: #0066cc;
            --accent-orange: #ff6b35;
            --accent-yellow: #ffd23f;
            --dark: #1a1a1a;
            --dark-secondary: #2a2a2a;
            --light: #f8f9fa;
            --gray: #6c757d;
            --gray-light: #e9ecef;
            --success: #28a745;
            --male-blue: #4a90e2;
            --female-pink: #e91e63;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--dark);
            line-height: 1.6;
            padding-bottom: 60px;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 16px;
        }

        /* Dashboard */
        .dashboard-header {
            text-align: center;
            padding: 40px 20px 30px;
            color: white;
            animation: fadeInDown 0.6s ease;
        }

        .dashboard-header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            letter-spacing: -1px;
            margin-bottom: 8px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .dashboard-header p {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            animation: fadeInUp 0.5s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn {
            display: block;
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--court-green), #3d7021);
            color: white;
            box-shadow: 0 4px 15px rgba(45, 80, 22, 0.3);
        }

        .btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(45, 80, 22, 0.4);
        }

        .btn-secondary {
            background: var(--light);
            color: var(--dark);
            border: 2px solid var(--gray-light);
        }

        .btn-secondary:hover {
            background: var(--gray-light);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.875rem;
            display: inline-block;
            width: auto;
        }

        /* Tournament List */
        .tournament-item {
            padding: 16px;
            border-bottom: 1px solid var(--gray-light);
            cursor: pointer;
            transition: background 0.2s;
        }

        .tournament-item:last-child {
            border-bottom: none;
        }

        .tournament-item:hover {
            background: var(--light);
        }

        .tournament-item h3 {
            font-size: 1.1rem;
            margin-bottom: 4px;
            color: var(--dark);
        }

        .tournament-item p {
            font-size: 0.875rem;
            color: var(--gray);
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-ongoing {
            background: #ffeaa7;
            color: #d63031;
        }

        .badge-completed {
            background: #dfe6e9;
            color: var(--gray);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            background: white;
            padding: 8px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            position: sticky;
            top: 16px;
            z-index: 100;
        }

        .tab {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--gray);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--court-green), #3d7021);
            color: white;
            box-shadow: 0 2px 8px rgba(45, 80, 22, 0.3);
        }

        /* Tournament Header */
        .tournament-header {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        .editable-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 12px;
            border: none;
            width: 100%;
            background: transparent;
            color: var(--dark);
            font-family: 'Outfit', sans-serif;
        }

        .editable-title:focus {
            outline: 2px solid var(--court-green);
            border-radius: 4px;
            padding: 4px;
        }

        .subtitle {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .subtitle input {
            border: none;
            background: var(--light);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.875rem;
            color: var(--gray);
        }

        .rules {
            background: var(--light);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.875rem;
            color: var(--gray);
            border: none;
            width: 100%;
            font-family: 'Outfit', sans-serif;
            resize: vertical;
            min-height: 60px;
        }

        /* Leaderboard */
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--gray-light);
            animation: fadeIn 0.3s ease;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .rank {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray);
            width: 50px;
            font-family: 'Space Mono', monospace;
        }

        .rank.gold { color: #ffd700; }
        .rank.silver { color: #c0c0c0; }
        .rank.bronze { color: #cd7f32; }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gender-badge {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
        }

        .gender-badge.male {
            background: var(--male-blue);
        }

        .gender-badge.female {
            background: var(--female-pink);
        }

        .player-stats {
            font-size: 0.875rem;
            color: var(--gray);
            font-family: 'Space Mono', monospace;
        }

        .points {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--court-green);
            font-family: 'Space Mono', monospace;
        }

        /* Games */
        .game-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: var(--shadow);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .game-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark);
        }

        .game-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .game-status.pending {
            background: #ffeaa7;
            color: #d63031;
        }

        .game-status.completed {
            background: #d4edda;
            color: var(--success);
        }

        .teams {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .team {
            flex: 1;
            background: var(--light);
            padding: 12px;
            border-radius: 8px;
        }

        .team-label {
            font-size: 0.75rem;
            color: var(--gray);
            margin-bottom: 4px;
            font-weight: 600;
        }

        .team-players {
            font-size: 0.875rem;
            font-weight: 600;
        }

        .score-input-group {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .score-input {
            flex: 1;
            text-align: center;
        }

        .score-input label {
            display: block;
            font-size: 0.75rem;
            color: var(--gray);
            margin-bottom: 4px;
        }

        .score-input input {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--gray-light);
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            font-family: 'Space Mono', monospace;
        }

        .vs-separator {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray);
        }

        /* Player Management */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .player-row input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--gray-light);
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
        }

        .gender-toggle {
            display: flex;
            gap: 4px;
        }

        .gender-toggle button {
            padding: 8px 12px;
            border: 2px solid var(--gray-light);
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .gender-toggle button.active.male {
            background: var(--male-blue);
            color: white;
            border-color: var(--male-blue);
        }

        .gender-toggle button.active.female {
            background: var(--female-pink);
            color: white;
            border-color: var(--female-pink);
        }

        /* Point System */
        .point-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }

        .point-input {
            text-align: center;
        }

        .point-input label {
            display: block;
            font-size: 0.75rem;
            color: var(--gray);
            margin-bottom: 4px;
            font-weight: 600;
        }

        .point-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--gray-light);
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            font-family: 'Space Mono', monospace;
        }

        /* Summary */
        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .summary-stat {
            background: var(--light);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .summary-stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--court-green);
            font-family: 'Space Mono', monospace;
        }

        .summary-stat-label {
            font-size: 0.875rem;
            color: var(--gray);
            margin-top: 4px;
        }

        .match-history-item {
            padding: 12px;
            background: var(--light);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.875rem;
        }

        .match-history-item .status-icon {
            margin-right: 8px;
            font-weight: 700;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 20px;
            color: white;
            font-size: 0.75rem;
            opacity: 0.7;
            margin-top: 40px;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hidden {
            display: none;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--gray-light);
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .section-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 20px 0 12px;
            color: var(--dark);
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .btn-group button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <div class="footer">
        Created by SG 2026 • Beta v1.0
    </div>

    <script>
        // State Management
        let state = {
            currentView: 'dashboard',
            currentTournament: null,
            tournaments: [],
            roundsSortReversed: true  // Default to reversed (newest first)
        };

        // Load tournaments from localStorage
        // Save tournaments to localStorage
        function saveTournaments() {
            // Convert Sets to Arrays for JSON serialization
            const tournamentsToSave = state.tournaments.map(t => {
                const tournamentCopy = JSON.parse(JSON.stringify(t));
                
                // Convert player Set objects to arrays
                if (tournamentCopy.players) {
                    tournamentCopy.players = tournamentCopy.players.map(p => ({
                        ...p,
                        partnerHistory: p.partnerHistory instanceof Set 
                            ? Array.from(p.partnerHistory) 
                            : (p.partnerHistory || []),
                        restHistory: p.restHistory || [],
                        roundsPlayed: p.roundsPlayed || 0
                    }));
                }
                
                return tournamentCopy;
            });
            
            localStorage.setItem('americano_tournaments', JSON.stringify(tournamentsToSave));
        }

        function loadTournaments() {
            const saved = localStorage.getItem('americano_tournaments');
            if (saved) {
                try {
                    state.tournaments = JSON.parse(saved);
                    
                    // Convert arrays back to Sets
                    state.tournaments.forEach(t => {
                        if (t.players) {
                            t.players.forEach(p => {
                                // Convert partnerHistory array to Set
                                if (Array.isArray(p.partnerHistory)) {
                                    p.partnerHistory = new Set(p.partnerHistory);
                                } else if (!p.partnerHistory) {
                                    p.partnerHistory = new Set();
                                }
                                
                                // Ensure restHistory is an array
                                if (!Array.isArray(p.restHistory)) {
                                    p.restHistory = [];
                                }
                                
                                // Ensure roundsPlayed exists
                                if (typeof p.roundsPlayed !== 'number') {
                                    p.roundsPlayed = 0;
                                }
                            });
                        }
                    });
                } catch (error) {
                    console.error('Error loading tournaments:', error);
                    state.tournaments = [];
                }
            }
        }

        // Initialize app
        loadTournaments();

        // Tournament Functions
        function createTournament() {
            const today = new Date();
            const defaultDuration = 2;
            const defaultCourts = 1;
            const tournament = {
                id: Date.now(),
                title: `Tournament Name? • ${defaultDuration}H${defaultCourts}C`,
                location: 'Court Location',
                date: today.toISOString().split('T')[0], // YYYY-MM-DD format
                startTime: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false }),
                durationHours: defaultDuration,
                americanoType: 'classic',
                gradingRounds: 4,
                courtCount: defaultCourts,
                players: [
                    { id: 1, name: 'Player 1', gender: 'M', grade: null },
                    { id: 2, name: 'Player 2', gender: 'F', grade: null },
                    { id: 3, name: 'Player 3', gender: 'M', grade: null },
                    { id: 4, name: 'Player 4', gender: 'F', grade: null }
                ],
                rounds: [],
                pointSystem: { win: 2, tie: 1, lose: 0 },
                status: 'ongoing',
                createdAt: Date.now()
            };
            state.tournaments.push(tournament);
            saveTournaments();
            state.currentTournament = tournament;
            state.currentView = 'tournament';
            render();
        }

        function loadTournament(id) {
            state.currentTournament = state.tournaments.find(t => t.id === id);
            state.currentView = 'tournament';
            render();
        }

        function deleteTournament(id) {
            if (confirm('Are you sure you want to delete this tournament?')) {
                state.tournaments = state.tournaments.filter(t => t.id !== id);
                saveTournaments();
                render();
            }
        }

        function completeTournamentFromDashboard(id) {
            if (confirm('Mark this tournament as completed?')) {
                const tournament = state.tournaments.find(t => t.id === id);
                if (tournament) {
                    tournament.status = 'completed';
                    saveTournaments();
                    render();
                }
            }
        }

        function updateTournament() {
            const index = state.tournaments.findIndex(t => t.id === state.currentTournament.id);
            if (index !== -1) {
                state.tournaments[index] = state.currentTournament;
                saveTournaments();
            }
        }

        // ============================================================================
        // DRAFT FEATURE: Advanced Americano Pairing Algorithm
        // Status: Beta - Testing Phase
        // Features: Dynamic player join, smart pairing, score balancing, fairness rotation
        // ============================================================================
        
        // Advanced Americano Pairing Algorithm
        // Based on dynamic pairing with partner history tracking and score balancing
        
        /**
         * Generate optimal pairings for Americano tournament
         * @param {Array} players - Array of player objects with {id, name, currentScore, partnerHistory, joinRound}
         * @param {number} currentRound - Current round number
         * @param {Array} newPlayers - Optional array of new players joining mid-tournament
         * @returns {Object} - Pairing result with pairs, bye player, and new player info
         */
        function generateAmericanoPairing(players, currentRound, newPlayers = []) {
            // Step 1: Add new players to the pool
            let allPlayers = [...players];
            const addedPlayers = [];
            
            if (newPlayers.length > 0) {
                newPlayers.forEach(newPlayer => {
                    // Calculate catch-up score for new players
                    const avgScore = players.length > 0 
                        ? players.reduce((sum, p) => sum + (p.currentScore || 0), 0) / players.length 
                        : 0;
                    
                    const playerWithHistory = {
                        ...newPlayer,
                        currentScore: Math.floor(avgScore * 0.7), // 70% of average for catch-up
                        partnerHistory: new Set(),
                        joinRound: currentRound
                    };
                    
                    allPlayers.push(playerWithHistory);
                    addedPlayers.push(playerWithHistory);
                });
            }
            
            // Step 2: Handle edge cases
            if (allPlayers.length < 4) {
                return {
                    pairs: [],
                    bye: null,
                    addedPlayers,
                    error: 'Need at least 4 players to start'
                };
            }
            
            // Step 3: Determine bye/resting players if not divisible by 4
            let byePlayers = [];
            let activePlayers = [...allPlayers];
            
            const remainder = allPlayers.length % 4;
            
            if (remainder !== 0) {
                // Calculate how many need to rest
                const playersToRest = remainder === 2 ? 2 : 1; // If 6 players (remainder 2), rest 2
                
                // Get rest statistics for all players
                const restStats = allPlayers.map(p => ({
                    player: p,
                    restCount: p.restHistory ? p.restHistory.length : 0,
                    lastRestRound: p.restHistory && p.restHistory.length > 0 
                        ? Math.max(...p.restHistory) 
                        : -999,
                    roundsPlayed: p.roundsPlayed || 0
                }));
                
                // Sort by: 1) rest count (ascending), 2) last rest round (ascending), 3) random for tiebreak
                restStats.sort((a, b) => {
                    if (a.restCount !== b.restCount) return a.restCount - b.restCount;
                    if (a.lastRestRound !== b.lastRestRound) return a.lastRestRound - b.lastRestRound;
                    return Math.random() - 0.5; // Random tiebreaker for fairness
                });
                
                // Select players to rest
                byePlayers = restStats.slice(0, playersToRest).map(s => s.player);
                activePlayers = allPlayers.filter(p => !byePlayers.some(bp => bp.id === p.id));
                
                console.log(`Rest rotation: ${byePlayers.map(p => p.name).join(', ')} resting this round`);
            }
            
            // Step 4: Generate pairings
            const pairs = [];
            const paired = new Set();
            
            // Create a copy of players for pairing
            let availablePlayers = [...activePlayers];
            
            // Step 4a: Handle new players first (priority pairing)
            const newPlayersInRound = availablePlayers.filter(p => p.joinRound === currentRound);
            newPlayersInRound.forEach(newPlayer => {
                if (paired.has(newPlayer.id)) return;
                
                // Find best partner: player with least partners who hasn't played with this player
                const potentialPartners = availablePlayers.filter(p => 
                    !paired.has(p.id) && 
                    p.id !== newPlayer.id &&
                    !newPlayer.partnerHistory.has(p.id)
                );
                
                if (potentialPartners.length > 0) {
                    // Sort by number of unique partners (ascending)
                    potentialPartners.sort((a, b) => {
                        const aPartners = a.partnerHistory ? a.partnerHistory.size : 0;
                        const bPartners = b.partnerHistory ? b.partnerHistory.size : 0;
                        return aPartners - bPartners;
                    });
                    
                    const partner = potentialPartners[0];
                    pairs.push({ player1: newPlayer, player2: partner });
                    paired.add(newPlayer.id);
                    paired.add(partner.id);
                }
            });
            
            // Step 4b: For round > 3, use score-based pairing (high-low matching)
            if (currentRound > 3) {
                // Sort remaining players by score
                const remaining = availablePlayers.filter(p => !paired.has(p.id));
                remaining.sort((a, b) => (b.currentScore || 0) - (a.currentScore || 0));
                
                // Pair highest with lowest, second highest with second lowest, etc.
                while (remaining.length >= 2) {
                    const high = remaining.shift();
                    const low = remaining.pop();
                    
                    // Check if they haven't played together
                    if (!high.partnerHistory.has(low.id)) {
                        pairs.push({ player1: high, player2: low });
                        paired.add(high.id);
                        paired.add(low.id);
                    } else {
                        // If they have played together, find next best option
                        let foundPair = false;
                        for (let i = remaining.length - 1; i >= 0; i--) {
                            if (!high.partnerHistory.has(remaining[i].id)) {
                                const partner = remaining.splice(i, 1)[0];
                                pairs.push({ player1: high, player2: partner });
                                paired.add(high.id);
                                paired.add(partner.id);
                                remaining.push(low); // Put low back
                                foundPair = true;
                                break;
                            }
                        }
                        
                        // If still no valid pair found, accept repeat pairing
                        if (!foundPair) {
                            pairs.push({ player1: high, player2: low });
                            paired.add(high.id);
                            paired.add(low.id);
                        }
                    }
                }
            } else {
                // Step 4c: For early rounds (1-3), use random pairing avoiding history
                const remaining = availablePlayers.filter(p => !paired.has(p.id));
                
                // Shuffle for randomness
                for (let i = remaining.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
                }
                
                while (remaining.length >= 2) {
                    const player1 = remaining.shift();
                    
                    // Find a partner who hasn't played with player1
                    let partnerIndex = remaining.findIndex(p => !player1.partnerHistory.has(p.id));
                    
                    // If all have played together, just take the first available
                    if (partnerIndex === -1) partnerIndex = 0;
                    
                    const player2 = remaining.splice(partnerIndex, 1)[0];
                    
                    pairs.push({ player1, player2 });
                    paired.add(player1.id);
                    paired.add(player2.id);
                }
            }
            
            return {
                pairs,
                byePlayers: byePlayers, // Array of bye players
                bye: byePlayers.length > 0 ? byePlayers[0] : null, // Keep for backward compatibility
                addedPlayers,
                error: null
            };
        }
        
        /**
         * Update partner history after pairing
         * @param {Array} players - Array of all players
         * @param {Array} pairs - Generated pairs from pairing algorithm
         */
        function updatePartnerHistory(players, pairs) {
            pairs.forEach(pair => {
                const p1 = players.find(p => p.id === pair.player1.id);
                const p2 = players.find(p => p.id === pair.player2.id);
                
                if (p1 && p2) {
                    if (!p1.partnerHistory) p1.partnerHistory = new Set();
                    if (!p2.partnerHistory) p2.partnerHistory = new Set();
                    
                    p1.partnerHistory.add(p2.id);
                    p2.partnerHistory.add(p1.id);
                }
            });
        }
        
        /**
         * Update rest history for bye player
         * @param {Object} player - Player who is resting
         * @param {number} round - Current round number
         */
        function updateRestHistory(player, round) {
            if (!player.restHistory) {
                player.restHistory = [];
            }
            player.restHistory.push(round);
        }

        // Americano Logic (Updated to use new algorithm)
        function shufflePlayers() {
            const players = [...state.currentTournament.players];
            for (let i = players.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [players[i], players[j]] = [players[j], players[i]];
            }
            state.currentTournament.players = players;
            updateTournament();
            render();
        }

        function generateRound() {
            const tournament = state.currentTournament;
            const roundNumber = tournament.rounds.length + 1;
            const courtCount = tournament.courtCount || 1;
            
            // DRAFT: Using new advanced pairing algorithm
            // Convert current players to algorithm format
            const playersForAlgo = tournament.players.map(p => ({
                id: p.id,
                name: p.name,
                gender: p.gender,
                currentScore: calculatePlayerStats(p.id).points,
                partnerHistory: p.partnerHistory || new Set(),
                joinRound: p.joinRound || 1,
                restHistory: p.restHistory || []
            }));
            
            // Check if this is bracket mode round
            const isBracketMode = tournament.americanoType === 'grading' && roundNumber <= tournament.gradingRounds;
            
            if (isBracketMode) {
                // For bracket mode rounds, use simple random pairing
                return generateRandomRound(roundNumber);
            } else if (tournament.americanoType === 'grading' && roundNumber > tournament.gradingRounds) {
                // After bracket mode, use grade-based pairing
                return generateGradedRound(roundNumber);
            } else {
                // DRAFT: Use new advanced algorithm for classic Americano
                const pairingResult = generateAmericanoPairing(playersForAlgo, roundNumber);
                
                if (pairingResult.error) {
                    alert(pairingResult.error);
                    return null;
                }
                
                // Convert pairing result to matches with court assignment
                const matches = [];
                let courtIndex = 1;
                
                console.log('=== PAIRING DEBUG ===');
                console.log('Court Count:', courtCount);
                console.log('Total Pairs:', pairingResult.pairs.length);
                console.log('Expected Matches:', Math.floor(pairingResult.pairs.length / 2));
                
                for (let i = 0; i < pairingResult.pairs.length; i += 2) {
                    if (i + 1 < pairingResult.pairs.length) {
                        const pair1 = pairingResult.pairs[i];
                        const pair2 = pairingResult.pairs[i + 1];
                        
                        console.log(`Creating Match ${matches.length + 1} on Court ${courtIndex}:`, 
                            pair1.player1.name, '+', pair1.player2.name, 'vs', 
                            pair2.player1.name, '+', pair2.player2.name);
                        
                        // Find actual player objects
                        const p1_1 = tournament.players.find(p => p.id === pair1.player1.id);
                        const p1_2 = tournament.players.find(p => p.id === pair1.player2.id);
                        const p2_1 = tournament.players.find(p => p.id === pair2.player1.id);
                        const p2_2 = tournament.players.find(p => p.id === pair2.player2.id);
                        
                        if (p1_1 && p1_2 && p2_1 && p2_2) {
                            matches.push({
                                id: Date.now() + matches.length * 100,
                                court: courtIndex,
                                team1: [p1_1, p1_2],
                                team2: [p2_1, p2_2],
                                score1: null,
                                score2: null,
                                status: 'pending'
                            });
                            
                            // Update partner history in tournament players
                            if (!p1_1.partnerHistory) p1_1.partnerHistory = new Set();
                            if (!p1_2.partnerHistory) p1_2.partnerHistory = new Set();
                            if (!p2_1.partnerHistory) p2_1.partnerHistory = new Set();
                            if (!p2_2.partnerHistory) p2_2.partnerHistory = new Set();
                            
                            p1_1.partnerHistory.add(p1_2.id);
                            p1_2.partnerHistory.add(p1_1.id);
                            p2_1.partnerHistory.add(p2_2.id);
                            p2_2.partnerHistory.add(p2_1.id);
                            
                            // Increment court index, cycle back if exceeds court count
                            courtIndex++;
                            if (courtIndex > courtCount) {
                                courtIndex = 1;
                            }
                        }
                    }
                }
                
                console.log('Total Matches Created:', matches.length);
                console.log('Matches:', matches.map(m => `Court ${m.court}`));
                console.log('===================');
                
                // Handle bye/resting players
                const byePlayerNames = [];
                if (pairingResult.byePlayers && pairingResult.byePlayers.length > 0) {
                    pairingResult.byePlayers.forEach(byePlayerData => {
                        const byePlayer = tournament.players.find(p => p.id === byePlayerData.id);
                        if (byePlayer) {
                            if (!byePlayer.restHistory) byePlayer.restHistory = [];
                            byePlayer.restHistory.push(roundNumber);
                            byePlayerNames.push(byePlayer.name);
                        }
                    });
                }
                
                // Track rounds played for active players
                matches.forEach(match => {
                    const allActivePlayers = [...match.team1, ...match.team2];
                    allActivePlayers.forEach(playerRef => {
                        const player = tournament.players.find(p => p.id === playerRef.id);
                        if (player) {
                            player.roundsPlayed = (player.roundsPlayed || 0) + 1;
                        }
                    });
                });
                
                return {
                    id: Date.now(),
                    number: roundNumber,
                    matches: matches,
                    byePlayer: byePlayerNames.length > 0 ? byePlayerNames.join(', ') : null
                };
            }
        }

        function generateRandomRound(roundNumber) {
            const players = [...state.currentTournament.players];
            const courtCount = state.currentTournament.courtCount || 1;
            
            // Shuffle players
            for (let i = players.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [players[i], players[j]] = [players[j], players[i]];
            }

            // Create matches (4 players per match) with court assignment
            const matches = [];
            let courtIndex = 1;
            
            for (let i = 0; i < players.length; i += 4) {
                if (i + 3 < players.length) {
                    matches.push({
                        id: Date.now() + i,
                        court: courtIndex,
                        team1: [players[i], players[i + 1]],
                        team2: [players[i + 2], players[i + 3]],
                        score1: null,
                        score2: null,
                        status: 'pending'
                    });
                    
                    // Cycle court assignment
                    courtIndex++;
                    if (courtIndex > courtCount) {
                        courtIndex = 1;
                    }
                }
            }

            return {
                id: Date.now(),
                number: roundNumber,
                matches: matches
            };
        }

        function generateGradedRound(roundNumber) {
            const courtCount = state.currentTournament.courtCount || 1;
            
            // Calculate player stats for grading
            const playerStats = state.currentTournament.players.map(player => {
                const stats = calculatePlayerStats(player.id);
                return {
                    ...player,
                    points: stats.points,
                    wins: stats.wins
                };
            });

            // Sort by points and wins
            playerStats.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.wins - a.wins;
            });

            // Divide into tiers
            const tierSize = Math.ceil(playerStats.length / 3);
            const topTier = playerStats.slice(0, tierSize);
            const midTier = playerStats.slice(tierSize, tierSize * 2);
            const lowTier = playerStats.slice(tierSize * 2);

            // Update grades
            topTier.forEach(p => {
                const player = state.currentTournament.players.find(pl => pl.id === p.id);
                player.grade = 'TOP';
            });
            midTier.forEach(p => {
                const player = state.currentTournament.players.find(pl => pl.id === p.id);
                player.grade = 'MID';
            });
            lowTier.forEach(p => {
                const player = state.currentTournament.players.find(pl => pl.id === p.id);
                player.grade = 'LOW';
            });

            // Create matches within tiers with court assignment
            const allPlayers = [...topTier, ...midTier, ...lowTier];
            const matches = [];
            let courtIndex = 1;
            
            for (let i = 0; i < allPlayers.length; i += 4) {
                if (i + 3 < allPlayers.length) {
                    matches.push({
                        id: Date.now() + i,
                        court: courtIndex,
                        team1: [allPlayers[i], allPlayers[i + 1]],
                        team2: [allPlayers[i + 2], allPlayers[i + 3]],
                        score1: null,
                        score2: null,
                        status: 'pending'
                    });
                    
                    // Cycle court assignment
                    courtIndex++;
                    if (courtIndex > courtCount) {
                        courtIndex = 1;
                    }
                }
            }

            return {
                id: Date.now(),
                number: roundNumber,
                matches: matches
            };
        }

        function addRound() {
            try {
                const round = generateRound();
                
                if (!round) {
                    alert('Unable to generate round. Please check if you have enough players.');
                    return;
                }
                
                if (!round.matches || round.matches.length === 0) {
                    alert('Unable to create matches. Need at least 4 active players.');
                    return;
                }
                
                state.currentTournament.rounds.push(round);
                updateTournament();
                render();
                
                console.log('Round added successfully:', round);
            } catch (error) {
                console.error('Error adding round:', error);
                alert('Error adding round: ' + error.message);
            }
        }

        function updateGameScore(roundId, matchId, score1, score2) {
            const round = state.currentTournament.rounds.find(r => r.id === roundId);
            if (!round) {
                console.error('Round not found:', roundId);
                return;
            }
            
            const matches = round.matches || round.games || [];
            const match = matches.find(m => m.id === matchId);
            
            if (match) {
                match.score1 = score1 !== '' && score1 !== null ? parseInt(score1) : null;
                match.score2 = score2 !== '' && score2 !== null ? parseInt(score2) : null;
                
                if (match.score1 !== null && match.score2 !== null) {
                    match.status = 'completed';
                } else {
                    match.status = 'pending';
                }
                
                // Update round.matches if using new structure
                if (round.matches) {
                    round.matches = matches;
                }
                
                updateTournament();
                render();
            }
        }

        function deleteRound(roundId) {
            if (confirm('Delete this round? All scores and partner history for this round will be lost.')) {
                try {
                    const roundToDelete = state.currentTournament.rounds.find(r => r.id === roundId);
                    
                    if (roundToDelete) {
                        // Clean up partner history from this round
                        const matches = roundToDelete.matches || roundToDelete.games || [];
                        matches.forEach(match => {
                            const allPlayers = [...match.team1, ...match.team2];
                            
                            // Remove partner relationships from this round
                            if (match.team1 && match.team1.length === 2) {
                                const p1 = state.currentTournament.players.find(p => p.id === match.team1[0].id);
                                const p2 = state.currentTournament.players.find(p => p.id === match.team1[1].id);
                                if (p1 && p1.partnerHistory) p1.partnerHistory.delete(match.team1[1].id);
                                if (p2 && p2.partnerHistory) p2.partnerHistory.delete(match.team1[0].id);
                            }
                            
                            if (match.team2 && match.team2.length === 2) {
                                const p1 = state.currentTournament.players.find(p => p.id === match.team2[0].id);
                                const p2 = state.currentTournament.players.find(p => p.id === match.team2[1].id);
                                if (p1 && p1.partnerHistory) p1.partnerHistory.delete(match.team2[1].id);
                                if (p2 && p2.partnerHistory) p2.partnerHistory.delete(match.team2[0].id);
                            }
                        });
                    }
                    
                    // Remove the round
                    state.currentTournament.rounds = state.currentTournament.rounds.filter(r => r.id !== roundId);
                    
                    // Renumber rounds
                    state.currentTournament.rounds.forEach((round, index) => {
                        round.number = index + 1;
                    });
                    
                    updateTournament();
                    render();
                    
                    console.log('Round deleted successfully');
                } catch (error) {
                    console.error('Error deleting round:', error);
                    alert('Error deleting round: ' + error.message);
                }
            }
        }

        // Statistics Functions
        function calculatePlayerStats(playerId) {
            const stats = { wins: 0, ties: 0, losses: 0, points: 0, pointsFor: 0, pointsAgainst: 0, diff: 0 };
            const pointSystem = state.currentTournament.pointSystem;

            state.currentTournament.rounds.forEach(round => {
                const matches = round.matches || round.games || [];
                matches.forEach(match => {
                    if (match.status !== 'completed') return;

                    const isInTeam1 = match.team1.some(p => p.id === playerId);
                    const isInTeam2 = match.team2.some(p => p.id === playerId);

                    if (!isInTeam1 && !isInTeam2) return;

                    // Calculate points for and against
                    if (isInTeam1) {
                        stats.pointsFor += match.score1;
                        stats.pointsAgainst += match.score2;
                    } else {
                        stats.pointsFor += match.score2;
                        stats.pointsAgainst += match.score1;
                    }

                    // Calculate W-T-L and total points
                    if (match.score1 > match.score2) {
                        if (isInTeam1) {
                            stats.wins++;
                            stats.points += pointSystem.win;
                        } else {
                            stats.losses++;
                            stats.points += pointSystem.lose;
                        }
                    } else if (match.score1 < match.score2) {
                        if (isInTeam2) {
                            stats.wins++;
                            stats.points += pointSystem.win;
                        } else {
                            stats.losses++;
                            stats.points += pointSystem.lose;
                        }
                    } else {
                        stats.ties++;
                        stats.points += pointSystem.tie;
                    }
                });
            });

            // Calculate diff (point difference)
            stats.diff = stats.pointsFor - stats.pointsAgainst;

            // Add compensation points if exists
            if (state.currentTournament.compensationPoints && state.currentTournament.compensationPoints[playerId]) {
                stats.points += state.currentTournament.compensationPoints[playerId].points;
                stats.compensation = state.currentTournament.compensationPoints[playerId].points;
            }

            return stats;
        }

        function getLeaderboard() {
            return state.currentTournament.players.map(player => ({
                ...player,
                stats: calculatePlayerStats(player.id)
            })).sort((a, b) => {
                // Sort by points first
                if (b.stats.points !== a.stats.points) {
                    return b.stats.points - a.stats.points;
                }
                // If points are equal, sort by diff (point difference)
                if (b.stats.diff !== a.stats.diff) {
                    return b.stats.diff - a.stats.diff;
                }
                // If diff is also equal, sort by wins
                if (b.stats.wins !== a.stats.wins) {
                    return b.stats.wins - a.stats.wins;
                }
                // Finally sort by losses (ascending)
                return a.stats.losses - b.stats.losses;
            });
        }

        // Player Management
        function addPlayer() {
            if (state.currentTournament.players.length >= 18) {
                alert('Maximum 18 players allowed');
                return;
            }
            const newPlayer = {
                id: Date.now(),
                name: `Player ${state.currentTournament.players.length + 1}`,
                gender: 'M',
                grade: null
            };
            state.currentTournament.players.push(newPlayer);
            updateTournament();
            render();
        }

        function updatePlayer(playerId, field, value) {
            const player = state.currentTournament.players.find(p => p.id === playerId);
            if (player) {
                player[field] = value;
                updateTournament();
            }
        }

        function resetTournament() {
            if (confirm('Reset all rounds and scores? Player data will be kept.')) {
                state.currentTournament.rounds = [];
                state.currentTournament.players.forEach(p => p.grade = null);
                updateTournament();
                render();
            }
        }

        // Render Functions
        function render() {
            const app = document.getElementById('app');
            
            if (state.currentView === 'dashboard') {
                app.innerHTML = renderDashboard();
            } else if (state.currentView === 'tournament') {
                app.innerHTML = renderTournament();
            }

            attachEventListeners();
        }

        function renderDashboard() {
            const ongoingTournaments = state.tournaments.filter(t => t.status === 'ongoing');
            const completedTournaments = state.tournaments.filter(t => t.status === 'completed');

            return `
                <div class="dashboard-header">
                    <h1>Tennis Score 🎾</h1>
                    <p>Free, Flexible, Offline Tournament Manager</p>
                </div>

                <div class="container">
                    <div class="card">
                        <button class="btn btn-primary" onclick="createTournament()">
                            ➕ Create New Tournament
                        </button>
                    </div>

                    ${ongoingTournaments.length > 0 ? `
                        <div class="card">
                            <h2 style="margin-bottom: 16px; font-size: 1.3rem;">Ongoing Tournaments</h2>
                            <div>
                                ${ongoingTournaments.map(t => {
                                    const durationHours = t.durationHours || 2;
                                    const courtCount = t.courtCount || 1;
                                    const xhyc = `${durationHours}H${courtCount}C`;
                                    
                                    return `
                                    <div class="tournament-item" style="display: flex; align-items: center; gap: 12px;">
                                        <div style="flex: 1;" onclick="loadTournament(${t.id})">
                                            <h3>
                                                ${t.title}
                                                <span class="badge badge-ongoing">LIVE</span>
                                            </h3>
                                            <p>${t.location} • ${new Date(t.createdAt).toLocaleDateString()} • ${xhyc}</p>
                                            <p style="margin-top: 4px; font-size: 0.8rem;">
                                                ${t.players.length} players • ${t.rounds.length} rounds
                                            </p>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 8px;">
                                            <button 
                                                onclick="event.stopPropagation(); completeTournamentFromDashboard(${t.id})"
                                                style="padding: 8px 12px; border: 2px solid #28a745; background: white; color: #28a745; border-radius: 8px; cursor: pointer; font-size: 1rem; transition: all 0.2s;"
                                                onmouseover="this.style.background='#28a745'; this.style.color='white';"
                                                onmouseout="this.style.background='white'; this.style.color='#28a745';"
                                                title="Complete tournament"
                                            >
                                                ✓
                                            </button>
                                            <button 
                                                onclick="event.stopPropagation(); deleteTournament(${t.id})"
                                                style="padding: 8px 12px; border: 2px solid #dc3545; background: white; color: #dc3545; border-radius: 8px; cursor: pointer; font-size: 1rem; transition: all 0.2s;"
                                                onmouseover="this.style.background='#dc3545'; this.style.color='white';"
                                                onmouseout="this.style.background='white'; this.style.color='#dc3545';"
                                                title="Delete tournament"
                                            >
                                                🗑️
                                            </button>
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${completedTournaments.length > 0 ? `
                        <div class="card">
                            <h2 style="margin-bottom: 16px; font-size: 1.3rem;">Tournament History</h2>
                            <div>
                                ${completedTournaments.map(t => `
                                    <div class="tournament-item" onclick="loadTournament(${t.id})">
                                        <h3>
                                            ${t.title}
                                            <span class="badge badge-completed">COMPLETED</span>
                                        </h3>
                                        <p>${t.location} • ${new Date(t.createdAt).toLocaleDateString()}</p>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderTournament() {
            return `
                <div class="container">
                    <button class="btn btn-secondary btn-small" onclick="backToDashboard()" style="margin-bottom: 16px;">
                        ← Back to Dashboard
                    </button>

                    ${renderTournamentHeader()}
                    ${renderTabs()}
                    ${renderTabContent()}
                </div>
            `;
        }

        function renderTournamentHeader() {
            const t = state.currentTournament;
            
            // Ensure all fields exist (backward compatibility)
            if (!t.durationHours) t.durationHours = 2;
            if (!t.courtCount) t.courtCount = 1;
            if (!t.date) t.date = new Date().toISOString().split('T')[0];
            
            // Format date for display (DD/MM/YYYY)
            const dateObj = new Date(t.date + 'T00:00:00');
            const displayDate = `${String(dateObj.getDate()).padStart(2, '0')}/${String(dateObj.getMonth() + 1).padStart(2, '0')}/${dateObj.getFullYear()}`;
            
            // Generate info: XHYC format
            const xhyc = `${t.durationHours}H${t.courtCount}C`;
            
            // Americano type display
            const americanoTypeDisplay = t.americanoType === 'classic' ? 'Classic Americano' : 'Bracket Mode';
            
            // Player count
            const playerCount = `${t.players.length} Players`;
            
            return `
                <div class="tournament-header">
                    <input 
                        type="text" 
                        class="editable-title" 
                        value="${t.title}"
                        onchange="updateTournamentField('title', this.value)"
                    />
                    <div class="subtitle">
                        <input 
                            type="text" 
                            placeholder="Location"
                            value="${t.location}"
                            onchange="updateTournamentField('location', this.value)"
                        />
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <label style="font-size: 0.7rem; color: var(--gray); font-weight: 600;">Date</label>
                                <input 
                                    type="date" 
                                    value="${t.date}"
                                    onchange="updateTournamentField('date', this.value); render();"
                                    style="padding: 8px; border: none; background: var(--light); border-radius: 6px; font-family: 'Outfit', sans-serif; font-size: 0.8rem; color: var(--gray); width: 100%;"
                                />
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <label style="font-size: 0.7rem; color: var(--gray); font-weight: 600;">Start Time</label>
                                <input 
                                    type="time" 
                                    value="${t.startTime}"
                                    onchange="updateTournamentField('startTime', this.value); render();"
                                    style="padding: 8px; border: none; background: var(--light); border-radius: 6px; font-family: 'Outfit', sans-serif; font-size: 0.8rem; color: var(--gray); width: 100%;"
                                />
                            </div>
                        </div>
                        <div style="background: linear-gradient(135deg, var(--court-green), #3d7021); padding: 10px 8px; border-radius: 6px; text-align: center; overflow: hidden;">
                            <div style="font-size: 0.7rem; font-weight: 600; color: white; font-family: 'Space Mono', monospace; line-height: 1.4; word-break: break-word;">
                                📅 ${displayDate}<br/>
                                ${xhyc} • ${americanoTypeDisplay}<br/>
                                ${playerCount}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderTabs() {
            const tabs = ['Leaderboard', 'Games', 'Summary', 'Settings'];
            const currentTab = state.currentTab || 'Leaderboard';

            return `
                <div class="tabs">
                    ${tabs.map(tab => `
                        <button 
                            class="tab ${currentTab === tab ? 'active' : ''}"
                            onclick="switchTab('${tab}')"
                        >
                            ${tab}
                        </button>
                    `).join('')}
                </div>
            `;
        }

        function renderTabContent() {
            const currentTab = state.currentTab || 'Leaderboard';

            try {
                switch(currentTab) {
                    case 'Leaderboard':
                        return renderLeaderboard();
                    case 'Games':
                        return renderGames();
                    case 'Summary':
                        return renderSummary();
                    case 'Settings':
                        return renderSettings();
                    default:
                        return '';
                }
            } catch (error) {
                console.error('Error rendering tab:', currentTab, error);
                return `
                    <div class="card">
                        <h2 style="color: #dc3545; margin-bottom: 16px;">⚠️ Error Loading ${currentTab}</h2>
                        <p style="color: var(--gray); margin-bottom: 12px;">There was an error loading this tab. This might be due to old tournament data.</p>
                        <button class="btn btn-primary" onclick="location.reload()">
                            🔄 Refresh Page
                        </button>
                        <div style="margin-top: 16px; padding: 12px; background: var(--light); border-radius: 8px; font-family: monospace; font-size: 0.75rem; color: #dc3545; word-break: break-all;">
                            ${error.message}
                        </div>
                    </div>
                `;
            }
        }

        function toggleRoundSort() {
            state.roundsSortReversed = !state.roundsSortReversed;
            render();
        }

        function shareLeaderboard() {
            // Get the leaderboard data
            const t = state.currentTournament;
            const leaderboard = getLeaderboard();
            
            // Format date
            const dateObj = new Date(t.date + 'T00:00:00');
            const displayDate = `${String(dateObj.getDate()).padStart(2, '0')}/${String(dateObj.getMonth() + 1).padStart(2, '0')}/${dateObj.getFullYear()}`;
            
            // Create canvas - Mobile optimized size
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size for mobile (9:20 ratio)
            canvas.width = 720;
            const rowHeight = 70;
            const headerHeight = 180;
            const footerHeight = 80;
            canvas.height = Math.min(1600, headerHeight + (leaderboard.length * rowHeight) + footerHeight);
            
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Header
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Outfit, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('🏆 ' + t.title + ' 🏆', canvas.width / 2, 60);
            
            ctx.font = '24px Outfit, sans-serif';
            ctx.fillText(`${t.location} • ${displayDate}`, canvas.width / 2, 100);
            ctx.fillText(`${t.americanoType === 'classic' ? 'Classic Americano' : 'Bracket Mode'} • ${t.players.length} Players`, canvas.width / 2, 135);
            
            // Leaderboard background
            ctx.fillStyle = 'white';
            ctx.fillRect(30, headerHeight, canvas.width - 60, leaderboard.length * rowHeight);
            
            // Table header
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(30, headerHeight, canvas.width - 60, rowHeight);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Outfit, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Rank', 60, headerHeight + 45);
            ctx.fillText('Player', 160, headerHeight + 45);
            ctx.textAlign = 'center';
            ctx.fillText('W-T-L', 430, headerHeight + 45);
            ctx.fillText('Diff', 540, headerHeight + 45);
            ctx.fillText('Pts', 630, headerHeight + 45);
            
            // Draw leaderboard rows
            leaderboard.forEach((player, index) => {
                const y = headerHeight + rowHeight + (index * rowHeight);
                
                // Alternating row colors
                if (index % 2 === 0) {
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(30, y, canvas.width - 60, rowHeight);
                }
                
                // Rank
                ctx.fillStyle = index === 0 ? '#ffd700' : index === 1 ? '#c0c0c0' : index === 2 ? '#cd7f32' : '#6c757d';
                ctx.font = 'bold 36px Space Mono, monospace';
                ctx.textAlign = 'left';
                ctx.fillText((index + 1).toString(), 60, y + 46);
                
                // Gender badge
                ctx.fillStyle = player.gender === 'M' ? '#4a90e2' : '#e91e63';
                ctx.beginPath();
                ctx.arc(145, y + 35, 16, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Outfit, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.gender, 145, y + 41);
                
                // Player name
                ctx.fillStyle = '#1a1a1a';
                ctx.font = 'bold 28px Outfit, sans-serif';
                ctx.textAlign = 'left';
                const maxNameWidth = 240;
                let playerName = player.name;
                ctx.fillText(playerName.length > 15 ? playerName.substring(0, 15) + '...' : playerName, 170, y + 44);
                
                // W-T-L
                ctx.fillStyle = '#6c757d';
                ctx.font = '22px Space Mono, monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${player.stats.wins}-${player.stats.ties}-${player.stats.losses}`, 430, y + 44);
                
                // Diff
                ctx.fillStyle = player.stats.diff >= 0 ? '#28a745' : '#dc3545';
                ctx.font = 'bold 26px Space Mono, monospace';
                ctx.fillText(player.stats.diff >= 0 ? `+${player.stats.diff}` : player.stats.diff.toString(), 540, y + 44);
                
                // Points
                ctx.fillStyle = '#2d5016';
                ctx.font = 'bold 32px Space Mono, monospace';
                ctx.fillText(player.stats.points.toString(), 630, y + 44);
            });
            
            // Footer
            const footerY = headerHeight + (leaderboard.length * rowHeight) + 50;
            ctx.fillStyle = 'white';
            ctx.font = '20px Outfit, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Created by SG 2026', canvas.width / 2, footerY);
            
            // Convert to blob and download
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${t.title.replace(/\s+/g, '_')}_Leaderboard.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function renderLeaderboard() {
            const leaderboard = getLeaderboard();
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 style="font-size: 1.5rem; text-align: center; flex: 1;">🏆 Campeones! 🏆</h2>
                        <button 
                            onclick="shareLeaderboard()"
                            style="padding: 0; background: transparent; border: none; cursor: pointer; font-size: 1.8rem; transition: all 0.2s; opacity: 0.7;"
                            title="Share Leaderboard"
                            onmouseover="this.style.opacity='1'; this.style.transform='scale(1.1)'"
                            onmouseout="this.style.opacity='0.7'; this.style.transform='scale(1)'"
                        >
                            📤
                        </button>
                    </div>
                    
                    ${leaderboard.length > 0 ? `
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: var(--light); border-bottom: 2px solid var(--gray-light);">
                                        <th style="padding: 8px; text-align: left; font-size: 0.75rem; color: var(--gray);">Rank</th>
                                        <th style="padding: 8px; text-align: left; font-size: 0.75rem; color: var(--gray);">Player</th>
                                        <th style="padding: 8px; text-align: center; font-size: 0.75rem; color: var(--gray);">W-T-L</th>
                                        <th style="padding: 8px; text-align: center; font-size: 0.75rem; color: var(--gray);">Diff</th>
                                        <th style="padding: 8px; text-align: center; font-size: 0.75rem; color: var(--gray);">Pts</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${leaderboard.map((player, index) => `
                                        <tr style="border-bottom: 1px solid var(--gray-light);">
                                            <td style="padding: 12px 8px;">
                                                <span class="rank ${index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : ''}" style="font-size: 1.2rem; font-weight: 700; font-family: 'Space Mono', monospace;">
                                                    ${index + 1}
                                                </span>
                                            </td>
                                            <td style="padding: 12px 8px;">
                                                <div style="display: flex; align-items: center; gap: 8px;">
                                                    <span class="gender-badge ${player.gender === 'M' ? 'male' : 'female'}" style="width: 20px; height: 20px; font-size: 0.65rem; display: inline-flex; align-items: center; justify-content: center;">
                                                        ${player.gender}
                                                    </span>
                                                    <div>
                                                        <div style="font-weight: 600; font-size: ${index === 0 ? '1.3rem' : index < 3 ? '1.15rem' : '0.95rem'};">${player.name}</div>
                                                        ${player.grade ? `<div style="font-size: 0.7rem; color: var(--gray);">(${player.grade})</div>` : ''}
                                                    </div>
                                                    ${player.stats.compensation ? `<span style="font-size: 0.7rem; color: #ff6b35;" title="Includes ${player.stats.compensation} compensation points">💰</span>` : ''}
                                                </div>
                                            </td>
                                            <td style="padding: 12px 8px; text-align: center;">
                                                <div style="font-size: 0.85rem; font-family: 'Space Mono', monospace; color: var(--gray);">
                                                    ${player.stats.wins}-${player.stats.ties}-${player.stats.losses}
                                                </div>
                                            </td>
                                            <td style="padding: 12px 8px; text-align: center;">
                                                <div style="font-size: 0.95rem; font-weight: 700; font-family: 'Space Mono', monospace; color: ${player.stats.diff >= 0 ? '#28a745' : '#dc3545'};">
                                                    ${player.stats.diff >= 0 ? '+' : ''}${player.stats.diff}
                                                </div>
                                            </td>
                                            <td style="padding: 12px 8px; text-align: center;">
                                                <div style="font-size: ${index === 0 ? '1.3rem' : index < 3 ? '1.15rem' : '1.1rem'}; font-weight: 700; font-family: 'Space Mono', monospace; color: var(--court-green);">
                                                    ${player.stats.points}
                                                </div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    ` : '<p style="text-align: center; color: var(--gray);">No games completed yet</p>'}
                </div>
            `;
        }

        function renderGames() {
            let rounds = [...state.currentTournament.rounds];
            const t = state.currentTournament;
            const courtCount = t.courtCount || 1;
            const activePlayers = t.players.length;
            const maxSimultaneousMatches = Math.floor(activePlayers / 4);
            const courtsUsed = Math.min(courtCount, maxSimultaneousMatches);
            
            // Apply sorting if reversed
            if (state.roundsSortReversed) {
                rounds = rounds.reverse();
            }
            
            return `
                ${courtCount > 1 && activePlayers < 8 ? `
                    <div style="background: #fff3cd; padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid #ffc107;">
                        <div style="font-size: 0.8rem; color: #856404;">
                            ℹ️ <strong>${courtCount} courts</strong> configured, but only <strong>${courtsUsed} court${courtsUsed > 1 ? 's' : ''}</strong> can be used with <strong>${activePlayers} players</strong>.
                            <br/>Need at least <strong>8 players</strong> for 2 simultaneous matches.
                        </div>
                    </div>
                ` : ''}
                
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button class="btn btn-primary" onclick="addRound()" style="flex: 1;">
                        ➕ Add Round
                    </button>
                    <button 
                        class="btn btn-secondary" 
                        onclick="toggleRoundSort()" 
                        style="width: 48px; height: 48px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;"
                    >
                        ${state.roundsSortReversed ? '⬆️' : '⬇️'}
                    </button>
                </div>

                ${rounds.length > 0 ? rounds.map(round => `
                    <div class="card">
                        <div class="game-header">
                            <div class="game-title">
                                Round ${round.number}
                                ${round.byePlayer ? `<span style="font-size: 0.75rem; color: var(--gray); margin-left: 8px;">• ${round.byePlayer} resting</span>` : ''}
                            </div>
                            <button 
                                class="btn btn-danger btn-small" 
                                onclick="deleteRound(${round.id})"
                                style="padding: 6px 12px; font-size: 0.75rem;"
                            >
                                🗑️ Delete
                            </button>
                        </div>
                        ${(round.matches || round.games || []).map(match => {
                            const isEditing = state.editingGame === match.id;
                            const courtNum = match.court || 1;
                            return `
                            <div style="margin-bottom: 16px; padding: 12px; background: var(--light); border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center;">
                                    <span class="game-status ${match.status}">
                                        ${match.status === 'completed' ? '✓ Completed' : '⏳ Pending'}
                                    </span>
                                    <span style="background: var(--court-green); color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 700; font-family: 'Space Mono', monospace;">
                                        Court ${courtNum}
                                    </span>
                                </div>
                                <div class="teams">
                                    <div class="team">
                                        <div class="team-label">Team 1</div>
                                        <div class="team-players">
                                            ${match.team1.map(p => `
                                                <span class="gender-badge ${p.gender === 'M' ? 'male' : 'female'}" style="width: 18px; height: 18px; font-size: 0.65rem;">${p.gender}</span>
                                                ${p.name}
                                            `).join(' & ')}
                                        </div>
                                    </div>
                                    <div class="team">
                                        <div class="team-label">Team 2</div>
                                        <div class="team-players">
                                            ${match.team2.map(p => `
                                                <span class="gender-badge ${p.gender === 'M' ? 'male' : 'female'}" style="width: 18px; height: 18px; font-size: 0.65rem;">${p.gender}</span>
                                                ${p.name}
                                            `).join(' & ')}
                                        </div>
                                    </div>
                                </div>
                                
                                ${isEditing || match.status === 'pending' ? `
                                    <div class="score-input-group" style="margin-top: 12px;">
                                        <div class="score-input">
                                            <label>Team 1 Score</label>
                                            <input 
                                                type="number" 
                                                min="0"
                                                value="${match.score1 !== null ? match.score1 : ''}"
                                                id="score1_${match.id}"
                                            />
                                        </div>
                                        <div class="vs-separator">:</div>
                                        <div class="score-input">
                                            <label>Team 2 Score</label>
                                            <input 
                                                type="number" 
                                                min="0"
                                                value="${match.score2 !== null ? match.score2 : ''}"
                                                id="score2_${match.id}"
                                            />
                                        </div>
                                    </div>
                                    <button 
                                        class="btn btn-primary" 
                                        onclick="submitGameScore(${round.id}, ${match.id})"
                                        style="margin-top: 12px; width: 100%;"
                                    >
                                        💾 ${match.status === 'completed' ? 'Update Score' : 'Submit Score'}
                                    </button>
                                ` : `
                                    <div style="margin-top: 12px; text-align: center; background: white; padding: 16px; border-radius: 8px;">
                                        <div style="font-size: 2rem; font-weight: 700; font-family: 'Space Mono', monospace; color: var(--court-green); margin-bottom: 8px;">
                                            ${match.score1} : ${match.score2}
                                        </div>
                                        <button 
                                            class="btn btn-secondary btn-small" 
                                            onclick="enableEditScore(${match.id})"
                                            style="width: 100%;"
                                        >
                                            ✏️ Edit Score
                                        </button>
                                    </div>
                                `}
                            </div>
                        `}).join('')}
                    </div>
                `).join('') : '<div class="card"><p style="text-align: center; color: var(--gray);">No rounds yet. Click "Add Round" to start!</p></div>'}
            `;
        }

        function submitGameScore(roundId, gameId) {
            const score1Input = document.getElementById(`score1_${gameId}`);
            const score2Input = document.getElementById(`score2_${gameId}`);
            
            const score1 = score1Input.value;
            const score2 = score2Input.value;
            
            if (score1 === '' || score2 === '') {
                alert('Please enter both scores');
                return;
            }
            
            updateGameScore(roundId, gameId, score1, score2);
            state.editingGame = null;
        }

        function enableEditScore(gameId) {
            state.editingGame = gameId;
            render();
        }

        function getPlayerRoundParticipation() {
            const t = state.currentTournament;
            const participation = {};

            // Initialize participation tracking
            t.players.forEach(player => {
                participation[player.id] = {
                    player: player,
                    completedRounds: 0,
                    pendingRounds: 0,
                    totalRounds: 0,
                    rounds: []
                };
            });

            // Track which rounds each player participated in
            t.rounds.forEach(round => {
                const matches = round.matches || round.games || [];
                matches.forEach(match => {
                    const allPlayers = [...match.team1, ...match.team2];
                    allPlayers.forEach(player => {
                        if (participation[player.id]) {
                            participation[player.id].totalRounds++;
                            participation[player.id].rounds.push({
                                roundNumber: round.number,
                                status: match.status,
                                result: match.status === 'completed' ? getPlayerGameResult(player.id, match) : null
                            });
                            
                            if (match.status === 'completed') {
                                participation[player.id].completedRounds++;
                            } else {
                                participation[player.id].pendingRounds++;
                            }
                        }
                    });
                });
            });

            return participation;
        }

        function getPlayerGameResult(playerId, match) {
            const isInTeam1 = match.team1.some(p => p.id === playerId);
            const isInTeam2 = match.team2.some(p => p.id === playerId);

            if (!isInTeam1 && !isInTeam2) return null;

            if (match.score1 > match.score2) {
                return isInTeam1 ? 'W' : 'L';
            } else if (match.score1 < match.score2) {
                return isInTeam2 ? 'W' : 'L';
            } else {
                return 'T';
            }
        }

        function getRoundBalanceAnalysis() {
            const participation = getPlayerRoundParticipation();
            const roundCounts = Object.values(participation).map(p => p.completedRounds);
            const maxRounds = Math.max(...roundCounts, 0);
            const minRounds = Math.min(...roundCounts, maxRounds);
            const avgRounds = roundCounts.length > 0 ? (roundCounts.reduce((a, b) => a + b, 0) / roundCounts.length).toFixed(1) : 0;

            const imbalanced = maxRounds - minRounds > 2;
            const playersNeedingCompensation = Object.values(participation)
                .filter(p => p.completedRounds < maxRounds - 1)
                .map(p => ({
                    ...p,
                    missingRounds: maxRounds - p.completedRounds,
                    compensationPoints: 0
                }));

            return {
                maxRounds,
                minRounds,
                avgRounds,
                imbalanced,
                playersNeedingCompensation,
                participation
            };
        }

        function applyAutoCompensation() {
            const t = state.currentTournament;
            const analysis = getRoundBalanceAnalysis();
            
            if (!analysis.imbalanced) {
                alert('Tournament is already balanced! No compensation needed.');
                return;
            }

            // Initialize compensation points if not exists
            if (!t.compensationPoints) {
                t.compensationPoints = {};
            }

            const avgPointsPerRound = t.pointSystem.win * 0.5 + t.pointSystem.tie * 0.3 + t.pointSystem.lose * 0.2;

            analysis.playersNeedingCompensation.forEach(playerData => {
                const compensation = Math.round(playerData.missingRounds * avgPointsPerRound);
                t.compensationPoints[playerData.player.id] = {
                    points: compensation,
                    type: 'auto'
                };
            });

            updateTournament();
            render();
            alert(`Auto-compensation applied to ${analysis.playersNeedingCompensation.length} player(s)!`);
        }

        function updateManualCompensation(playerId, points) {
            const t = state.currentTournament;
            if (!t.compensationPoints) {
                t.compensationPoints = {};
            }

            if (points === 0 || points === '') {
                delete t.compensationPoints[playerId];
            } else {
                t.compensationPoints[playerId] = {
                    points: parseInt(points),
                    type: 'manual'
                };
            }

            updateTournament();
            render();
        }

        function clearAllCompensation() {
            if (confirm('Clear all compensation points?')) {
                state.currentTournament.compensationPoints = {};
                updateTournament();
                render();
            }
        }

        function renderSummary() {
            try {
                const t = state.currentTournament;
                
                // Safety check
                if (!t || !t.rounds) {
                    return '<div class="card"><p style="text-align: center; color: var(--gray);">No tournament data available</p></div>';
                }
                
                // Calculate completed rounds safely
                const completedRounds = t.rounds.filter(r => {
                    const matches = r.matches || r.games || [];
                    if (matches.length === 0) return false;
                    return matches.every(m => m && m.status === 'completed');
                }).length;
                
                const pendingRounds = t.rounds.length - completedRounds;
                const leaderboard = getLeaderboard();
                const analysis = getRoundBalanceAnalysis();
                const participation = analysis.participation;

                // Safety check for participation
                if (!participation) {
                    return '<div class="card"><p style="text-align: center; color: var(--gray);">Unable to load player data</p></div>';
                }

            return `
                <div class="card">
                    <h2 style="margin-bottom: 20px; font-size: 1.5rem; text-align: center;">📊 Tournament Summary</h2>
                    
                    <div class="summary-grid">
                        <div class="summary-stat">
                            <div class="summary-stat-value">${t.players.length}</div>
                            <div class="summary-stat-label">Total Players</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${t.rounds.length}</div>
                            <div class="summary-stat-label">Total Rounds</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${completedRounds}</div>
                            <div class="summary-stat-label">Completed</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${pendingRounds}</div>
                            <div class="summary-stat-label">Pending</div>
                        </div>
                    </div>

                    <h3 class="section-title">👥 Player Analysis</h3>
                    ${leaderboard.length > 0 ? `
                        <div style="background: white; border-radius: 12px; overflow: hidden; border: 2px solid var(--gray-light);">
                            ${leaderboard.map((player, index) => {
                                const playerParticipation = participation[player.id];
                                
                                // Safety check
                                if (!playerParticipation) {
                                    console.warn('No participation data for player:', player.id);
                                    return '';
                                }
                                
                                const needsCompensation = playerParticipation.completedRounds < analysis.maxRounds - 1;
                                
                                return `
                                <div style="border-bottom: 1px solid var(--gray-light); ${index === leaderboard.length - 1 ? 'border-bottom: none;' : ''}">
                                    <div style="display: flex; align-items: center; padding: 12px 16px; ${needsCompensation ? 'background: #fff3cd;' : ''}">
                                        <div class="rank ${index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : ''}" style="width: 35px; font-size: 1rem;">
                                            ${index + 1}
                                        </div>
                                        <div style="flex: 1; padding: 0 12px;">
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <span class="gender-badge ${player.gender === 'M' ? 'male' : 'female'}" style="width: 20px; height: 20px; font-size: 0.65rem;">
                                                    ${player.gender}
                                                </span>
                                                <strong style="font-size: 0.95rem;">${player.name}</strong>
                                                ${needsCompensation ? '<span style="font-size: 0.7rem; color: #856404; margin-left: 4px;">⚠️</span>' : ''}
                                            </div>
                                        </div>
                                        <div style="text-align: center; margin-right: 12px;">
                                            <div style="font-size: 0.95rem; font-weight: 700; font-family: 'Space Mono', monospace; color: ${needsCompensation ? '#856404' : 'var(--court-green)'};">
                                                ${playerParticipation.completedRounds}/${analysis.maxRounds}
                                            </div>
                                            <div style="font-size: 0.65rem; color: var(--gray);">rounds</div>
                                        </div>
                                        <button 
                                            class="btn btn-secondary btn-small" 
                                            onclick="togglePlayerAnalysis(${player.id})"
                                            style="padding: 6px 12px; font-size: 0.75rem;"
                                        >
                                            📊
                                        </button>
                                    </div>
                                    
                                    ${state.expandedPlayerId === player.id ? `
                                        <div style="padding: 16px; background: var(--light); border-top: 1px solid var(--gray-light);">
                                            <h4 style="font-size: 0.9rem; margin-bottom: 12px; color: var(--dark);">📊 Match History</h4>
                                            
                                            <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px;">
                                                ${playerParticipation.rounds.map(r => `
                                                    <span style="
                                                        display: inline-block;
                                                        padding: 4px 8px;
                                                        border-radius: 6px;
                                                        font-size: 0.7rem;
                                                        font-weight: 600;
                                                        font-family: 'Space Mono', monospace;
                                                        background: ${r.status === 'completed' 
                                                            ? (r.result === 'W' ? '#d4edda' : r.result === 'L' ? '#f8d7da' : '#fff3cd')
                                                            : '#e9ecef'};
                                                        color: ${r.status === 'completed'
                                                            ? (r.result === 'W' ? '#155724' : r.result === 'L' ? '#721c24' : '#856404')
                                                            : '#6c757d'};
                                                    ">
                                                        R${r.roundNumber}${r.status === 'completed' ? ` ${r.result}` : ' ⏳'}
                                                    </span>
                                                `).join('')}
                                            </div>

                                            ${needsCompensation || (t.compensationPoints && t.compensationPoints[player.id]) ? `
                                                <div style="background: white; padding: 12px; border-radius: 8px; margin-top: 12px; border: 2px solid #ffc107;">
                                                    <div style="font-size: 0.875rem; font-weight: 600; margin-bottom: 8px; color: var(--dark);">
                                                        💰 Compensation Points
                                                    </div>
                                                    <div style="display: flex; gap: 8px; align-items: center;">
                                                        <input 
                                                            type="number" 
                                                            value="${t.compensationPoints && t.compensationPoints[player.id] ? t.compensationPoints[player.id].points : 0}"
                                                            id="comp_${player.id}"
                                                            style="flex: 1; padding: 8px; border: 2px solid var(--gray-light); border-radius: 6px; font-family: 'Space Mono', monospace; font-weight: 700;"
                                                            placeholder="0"
                                                        />
                                                        <button 
                                                            onclick="updateManualCompensation(${player.id}, document.getElementById('comp_${player.id}').value)"
                                                            style="padding: 8px 16px; background: linear-gradient(135deg, var(--court-green), #3d7021); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s;"
                                                            onmouseover="this.style.transform='scale(1.05)'"
                                                            onmouseout="this.style.transform='scale(1)'"
                                                        >
                                                            ${t.compensationPoints && t.compensationPoints[player.id] ? '✏️ Edit' : '💾 Submit'}
                                                        </button>
                                                    </div>
                                                    ${t.compensationPoints && t.compensationPoints[player.id] ? `
                                                        <div style="font-size: 0.75rem; color: var(--gray); margin-top: 4px;">
                                                            ${t.compensationPoints[player.id].type === 'auto' ? '🤖 Auto-calculated' : '✏️ Manual entry'}
                                                        </div>
                                                    ` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            `}).join('')}
                        </div>
                    ` : '<p style="text-align: center; color: var(--gray); padding: 20px;">No completed games yet</p>'}

                    ${analysis.imbalanced ? `
                        <div style="background: #fff3cd; padding: 16px; border-radius: 12px; margin-top: 16px; border: 2px solid #ffc107;">
                            <div style="font-weight: 600; margin-bottom: 8px; color: #856404;">
                                ⚠️ Round Imbalance Detected
                            </div>
                            <div style="font-size: 0.875rem; color: #856404; margin-bottom: 12px;">
                                ${analysis.playersNeedingCompensation.length} player(s) have significantly fewer rounds (Range: ${analysis.minRounds}-${analysis.maxRounds})
                            </div>
                            <button class="btn btn-primary btn-small" onclick="applyAutoCompensation()" style="width: 100%;">
                                🤖 Apply Auto-Compensation
                            </button>
                        </div>
                    ` : ''}

                    ${t.compensationPoints && Object.keys(t.compensationPoints).length > 0 ? `
                        <button class="btn btn-danger btn-small" onclick="clearAllCompensation()" style="width: 100%; margin-top: 12px;">
                            🗑️ Clear All Compensation
                        </button>
                    ` : ''}
                </div>
            `;
            } catch (error) {
                console.error('Error rendering Summary tab:', error);
                return `
                    <div class="card">
                        <h2 style="margin-bottom: 20px; font-size: 1.5rem; text-align: center;">📊 Tournament Summary</h2>
                        <div style="background: #f8d7da; padding: 16px; border-radius: 8px; border: 2px solid #dc3545; margin: 20px 0;">
                            <p style="color: #721c24; margin-bottom: 8px;"><strong>⚠️ Error loading summary</strong></p>
                            <p style="color: #721c24; font-size: 0.875rem;">Please try refreshing the page or contact support if the issue persists.</p>
                            <p style="color: #721c24; font-size: 0.75rem; margin-top: 8px; font-family: monospace;">${error.message}</p>
                        </div>
                    </div>
                `;
            }
        }

        function togglePlayerAnalysis(playerId) {
            if (state.expandedPlayerId === playerId) {
                state.expandedPlayerId = null;
            } else {
                state.expandedPlayerId = playerId;
            }
            render();
        }

        function togglePlayerGender(playerId) {
            const player = state.currentTournament.players.find(p => p.id === playerId);
            if (player) {
                player.gender = player.gender === 'M' ? 'F' : 'M';
                updateTournament();
                render();
            }
        }

        function deletePlayer(playerId) {
            if (state.currentTournament.players.length <= 4) {
                alert('Minimum 4 players required!');
                return;
            }
            
            if (confirm('Delete this player? This cannot be undone.')) {
                state.currentTournament.players = state.currentTournament.players.filter(p => p.id !== playerId);
                updateTournament();
                render();
            }
        }

        function renderSettings() {
            const t = state.currentTournament;
            const hasRounds = t.rounds.length > 0;
            
            // Ensure courtCount exists (for backward compatibility)
            if (!t.courtCount) {
                t.courtCount = 1;
            }

            return `
                <div class="card">
                    <h2 class="section-title">⚙️ Tournament Settings</h2>

                    <h3 style="font-size: 1rem; margin-bottom: 8px;">⚙️ Tournament Setup</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                        <div>
                            <label style="font-size: 0.875rem; color: var(--gray); display: block; margin-bottom: 4px;">🎾 Courts</label>
                            <select onchange="updateTournamentField('courtCount', parseInt(this.value)); render();" style="width: 100%; padding: 10px; border: 2px solid var(--gray-light); border-radius: 8px; font-family: 'Outfit', sans-serif;">
                                <option value="1" ${t.courtCount === 1 ? 'selected' : ''}>1 Court</option>
                                <option value="2" ${t.courtCount === 2 ? 'selected' : ''}>2 Courts</option>
                                <option value="3" ${t.courtCount === 3 ? 'selected' : ''}>3 Courts</option>
                                <option value="4" ${t.courtCount === 4 ? 'selected' : ''}>4 Courts</option>
                            </select>
                        </div>
                        <div>
                            <label style="font-size: 0.875rem; color: var(--gray); display: block; margin-bottom: 4px;">⏱️ Duration</label>
                            <select onchange="updateTournamentField('durationHours', parseInt(this.value)); render();" style="width: 100%; padding: 10px; border: 2px solid var(--gray-light); border-radius: 8px; font-family: 'Outfit', sans-serif;">
                                ${[1,2,3,4,5,6,7,8].map(h => `
                                    <option value="${h}" ${t.durationHours === h ? 'selected' : ''}>${h} hour${h > 1 ? 's' : ''}</option>
                                `).join('')}
                            </select>
                        </div>
                    </div>

                    ${!hasRounds ? `
                        <h3 style="font-size: 1rem; margin-bottom: 8px;">Game Mode</h3>
                        <select onchange="updateTournamentField('americanoType', this.value)">
                            <option value="classic" ${t.americanoType === 'classic' ? 'selected' : ''}>Classic Americano</option>
                            <option value="grading" ${t.americanoType === 'grading' ? 'selected' : ''}>Bracket Mode (Americano)</option>
                        </select>

                        ${t.americanoType === 'grading' ? `
                            <div style="margin-bottom: 20px;">
                                <label style="font-size: 0.875rem; color: var(--gray);">Bracket Rounds (default 4)</label>
                                <input 
                                    type="number" 
                                    min="2" 
                                    max="10"
                                    value="${t.gradingRounds}"
                                    onchange="updateTournamentField('gradingRounds', parseInt(this.value))"
                                    style="width: 100%; padding: 10px; border: 2px solid var(--gray-light); border-radius: 8px; margin-top: 4px;"
                                />
                            </div>
                        ` : ''}

                        <button class="btn btn-primary" onclick="shufflePlayers()">
                            🔀 Shuffle Players
                        </button>
                    ` : ''}

                    <h3 class="section-title">👥 Players (${t.players.length}/18)</h3>
                    <div class="player-list">
                        ${t.players.map(player => `
                            <div class="player-row">
                                <input 
                                    type="text" 
                                    value="${player.name}"
                                    onchange="updatePlayer(${player.id}, 'name', this.value)"
                                />
                                <button 
                                    onclick="togglePlayerGender(${player.id})"
                                    class="gender-badge ${player.gender === 'M' ? 'male' : 'female'}"
                                    style="width: 32px; height: 32px; border: none; cursor: pointer; transition: all 0.2s; font-size: 0.75rem; font-weight: 700;"
                                    title="Click to toggle gender"
                                >
                                    ${player.gender}
                                </button>
                                <button 
                                    onclick="deletePlayer(${player.id})"
                                    style="padding: 6px 8px; border: 2px solid #dc3545; background: white; color: #dc3545; border-radius: 6px; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;"
                                    onmouseover="this.style.background='#dc3545'; this.style.color='white';"
                                    onmouseout="this.style.background='white'; this.style.color='#dc3545';"
                                    title="Delete player"
                                >
                                    🗑️
                                </button>
                            </div>
                        `).join('')}
                    </div>

                    ${t.players.length < 18 ? `
                        <button class="btn btn-secondary" onclick="addPlayer()" style="margin-top: 12px;">
                            ➕ Add Player
                        </button>
                    ` : ''}

                    <h3 class="section-title">🎯 Point System</h3>
                    <div class="point-inputs">
                        <div class="point-input">
                            <label>Win</label>
                            <input 
                                type="number" 
                                min="0"
                                value="${t.pointSystem.win}"
                                onchange="updatePointSystem('win', parseInt(this.value))"
                            />
                        </div>
                        <div class="point-input">
                            <label>Tie</label>
                            <input 
                                type="number" 
                                min="0"
                                value="${t.pointSystem.tie}"
                                onchange="updatePointSystem('tie', parseInt(this.value))"
                            />
                        </div>
                        <div class="point-input">
                            <label>Lose</label>
                            <input 
                                type="number" 
                                min="0"
                                value="${t.pointSystem.lose}"
                                onchange="updatePointSystem('lose', parseInt(this.value))"
                            />
                        </div>
                    </div>

                    <h3 class="section-title">🔧 Actions</h3>
                    <button class="btn btn-danger" onclick="resetTournament()">
                        🔄 Reset Tournament
                    </button>
                    <button class="btn btn-danger" onclick="deleteTournament(${t.id}); backToDashboard();" style="margin-top: 8px;">
                        🗑️ Delete Tournament
                    </button>
                </div>
            `;
        }

        // Event Handlers
        function backToDashboard() {
            state.currentView = 'dashboard';
            state.currentTournament = null;
            state.currentTab = null;
            render();
        }

        function switchTab(tab) {
            try {
                state.currentTab = tab;
                render();
            } catch (error) {
                console.error('Error switching to tab:', tab, error);
                alert('Error loading ' + tab + ' tab. Please refresh the page.');
            }
        }

        function updateTournamentField(field, value) {
            state.currentTournament[field] = value;
            updateTournament();
        }

        function updatePointSystem(field, value) {
            state.currentTournament.pointSystem[field] = value;
            updateTournament();
            render();
        }

        function attachEventListeners() {
            // Event listeners are attached inline via onclick attributes
            // This function is kept for compatibility
        }

        // Initial render
        render();
    </script>
</body>
</html>
